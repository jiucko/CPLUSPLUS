# 排序
### 通用术语
+ 稳定 
	如果a原本在b前面，而a==b,排序后a依然在b的前面
+ 不稳定
	如果a原本在b前面，而a == b,排序后a可能出现在b的后面
+ 内排序
	所有排序操作都是在内存中完成的
+ 外排序
	由于数据量太大，因此把数据放到磁盘中。而排序通过磁盘和内存的数据传输才能进行
### 排序算法总结
![](https://img2018.cnblogs.com/blog/778849/201811/778849-20181127150417498-619053967.png)
#### 图片名词解释
n：数据规模
k:"桶"的个数
In-place:占用常数内存
Out_place:占用额外内存
#### 排序分类:

![](https://img2018.cnblogs.com/blog/778849/201811/778849-20181127150507597-1382612531.png)
## 交换类排序
### 冒泡排序（Bubble Sort）
	+ 比较相邻的元素，如果第一个比第二个大，就交换它们两个
	+ 对每对相邻的元素作相同的工作，从开始的第一对到队尾的最后一对
	+ 针对所有元素重复以上步骤，
每一次循环可保证未排序中最大的元素沉到未排序的队列队尾。
##### 算法分析
最好情况：当未排序的数据已经是正序的，只需要遍历一次，时间复杂度O(N)，内部循环不用走。
最差情况：逆序的数据，每一次都想需要去交换，时间复杂度是O(n
^2)
平均情况：O(n^2)
### 快速排序
冒泡排序是相邻的两个数据进行比较和交换，每次交换只能上移或下移一个位置，导致总的比较与移动的次数较多。快排又称为分区交换排序，是对冒泡排序的改进，快排采用的思想是
##### 算法原理
+ 将待排序的n个记录中任意选取一个记录未分区标准
+ 将所有小于该标准的记录移动到左边，将所有大于该记录的移动到右边。将中间存放该记录。
+ 然后对子序列重复该过程。
##### 算法分析
+ 最好的情况：每次根据标准分区后，左右的字文件长度大致相等。T(n) = nlogn
+ 最坏的情况：是待排序记录是已排序的，第一次经过n-1次比较第一个记录位置不变，并得到一个n-1的子记录。第二次经过n-2次比较，将第二个记录放在原来的位置上。此时，时间复杂度T(n) = O(n^2)
## 选择类排序
### 选择排序（Selection Sort）
基本思想： 在未排序中找到最小（大）的元素，存放在未排序的起始位置。
##### 算法分析
最好 最还 平均都是O（n^2）
### 堆排序
直接选择排序中，每一选择经过n-1次比较，只是从排序码序列中选出了一个最小的排序码，而没有保存其它中间的比较结果，所以后一趟排序中又要重复许多操作，降低了效率。
#### 堆的性质
+ 堆是一颗完全二叉树
+ 大顶堆：父节点键值不小于子节点的键值。小顶堆：父节点不大于子节点的键值
+ 左右孩子没有顺序
+ 堆的存储一般采用一维数组。

堆排序其实是一次建立大（小）顶堆的过程，由于每次调整堆的时间复杂度是O(logN)，所以总的时间复制度是O（NlogN）
最坏情况：如果待排序的数组本身是有序的，使用堆排序仍然需要O（NlogN）
堆排序相较于快排的优势是数据的初始分布对排序的效率没有影响。
## 插入类排序
插入排序的基本方法是：每一步将一个待排序的记录，按期排序码的大小，查到前面已排序好的文件中的适当的位置，知道全部插入完为止。
### 直接插入排序
算法思想： 通过构建有序队列，对未排序的数据在已排序列中从后向前扫描，找到对应的位置并插入。通常，在向前扫描的过程中，因为不希望占用额外内存，需要将已排序的元素逐步往后移，为新元素腾出位置。
#### 改进的插入排序
查找位置的时候使用二分法
#### 算法分析
+ 最好情况：输入数组已经按升序排列好。T(n) = O(n)
+ 最坏情况：输入数组降序排列。T（n）= O(n^2)
+ 平均情况：T(n) = O（n^2）

### 希尔排序
Shell 排序又称为缩小增量排序。
Shell排序法是对相邻指定距离的元素进行比较，并不断把增量缩小到1，完成排序。
Shell排序开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，回来增量逐渐减小，分组数量较多，但是此时文件已趋于有序了。所以每次循环较快。
时间复制度在O(n^1.3)到O(n^2),实际所需时间与增量的个数和取值有关。通常取值为n/2，，当然也有建议n/3
## 归并排序
归并排序属于比较类非线性时间排序，比较类排序中性能更好。归并排序是分治法的典型应用，将已排序的子序列合并，得到完全有序的排列；即先使每个子序列有序，再使两个有序表合成一个有序表。
#### 算法分析
最好最坏情况都是O（nlogn）
优化，可以通过并行，多线程进行排序。
## 记数排序
计数排序的核心是将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复制度的排序，计数排序要求输入的数据必须要有确定的范围。
### 基数排序
桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。

<1>.取得数组中的最大数，并取得位数；
<2>.arr为原始数组，从最低位开始取每个位组成radix数组；
<3>.对radix进行计数排序（利用计数排序适用于小范围数的特点）